// Generated by CoffeeScript 1.4.0
(function() {
  var ImageEyeDropper, normalizeRgba;

  ImageEyeDropper = (function() {

    function ImageEyeDropper(img, opts) {
      if (opts == null) {
        opts = {};
      }
      this.fnStack = {};
      this.opts = opts;
      this.load(img);
    }

    ImageEyeDropper.prototype.load = function(img) {
      var imgObj,
        _this = this;
      if (typeof img === 'string') {
        if ((imgObj = document.getElementById(img)) && imgObj.tagName === 'IMG') {
          img = imgObj;
        }
      }
      this._loaded = false;
      return (this.img = img).addEventListener('load', function() {
        return _this._imageLoaded();
      });
    };

    ImageEyeDropper.prototype.isReady = function() {
      return this._loaded;
    };

    ImageEyeDropper.prototype._imageLoaded = function() {
      var canvas, ctx, h, rgbaData, w,
        _this = this;
      this.canvas = document.createElement('canvas');
      this.canvas.width = this.width = w = this.img.width;
      this.canvas.height = this.height = h = this.img.height;
      this.ctx = this.canvas.getContext('2d');
      this.ctx.drawImage(this.img, 0, 0, w, h);
      this.data = this.ctx.getImageData(0, 0, w, h).data;
      canvas = document.createElement('canvas');
      canvas.width = w = 64;
      canvas.height = h = 64 * this.height / this.width;
      ctx = canvas.getContext('2d');
      ctx.drawImage(this.img, 0, 0, w, h);
      rgbaData = ctx.getImageData(0, 0, w, h).data;
      this.analyzeData(rgbaData, w * h);
      if (this.opts.disableMouse !== true) {
        this.img.addEventListener('click', function(e) {
          return _this.imgClick(e);
        });
        return this.img.addEventListener('mousemove', function(e) {
          return _this.imgMousemove(e);
        });
      }
    };

    ImageEyeDropper.prototype.analyzeData = function(d, len) {
      var buckets, color1, color2, diff, getAvgColor, getAvgHueColor, hsvData, i, indexPrimary, indexSecondary, lengths, popMax, quarter, sat, secondary_tries, val, _b, _fn, _i, _j,
        _this = this;
      hsvData = [];
      buckets = [];
      _b = 100;
      sat = 0;
      val = 0;
      for (i = _i = 0; 0 <= _b ? _i <= _b : _i >= _b; i = 0 <= _b ? ++_i : --_i) {
        buckets[i] = [];
      }
      _fn = function(i) {
        var hex, hsva, _ref, _ref1;
        hex = normalizeRgba(d[i = i * 4], d[i + 1], d[i + 2]).toHex();
        hsva = color.hsva(hex).toArray();
        hsvData.push(hsva);
        if ((0.90 > (_ref = hsva[1]) && _ref > 0.10) && (0.9 > (_ref1 = hsva[2]) && _ref1 > 0.1)) {
          sat += hsva[1];
          val += hsva[2];
          return buckets[parseInt(_b * hsva[0], 10)].push(hsva);
        }
      };
      for (i = _j = 0; 0 <= len ? _j <= len : _j >= len; i = 0 <= len ? ++_j : --_j) {
        _fn(i);
      }
      this.avgSat = sat / len;
      this.avgVal = val / len;
      lengths = buckets.map(function(b) {
        return b.length;
      });
      popMax = function() {
        var index, max;
        max = Math.max.apply(null, lengths);
        lengths[index = lengths.indexOf(max)] = 0;
        return index;
      };
      indexPrimary = popMax();
      quarter = _b / 6;
      secondary_tries = 0;
      while ((diff = Math.abs((indexSecondary = popMax()) - indexPrimary)) < quarter) {
        if (++secondary_tries > _b) {
          break;
        }
      }
      getAvgColor = function(s, c) {
        s.h += c[0];
        s.s += c[1];
        return s.v += c[2];
      };
      getAvgHueColor = function(index) {
        var hsl, hsva, l, s, _k, _len, _ref;
        l = buckets[index].length;
        s = {
          h: 0,
          s: 0,
          v: 0
        };
        _ref = buckets[index];
        for (_k = 0, _len = _ref.length; _k < _len; _k++) {
          hsva = _ref[_k];
          getAvgColor(s, hsva);
        }
        hsl = {
          h: s.h / l || 0,
          s: s.s / l || 0,
          v: s.v / l || 0
        };
        return color.hsva(hsl);
      };
      color1 = getAvgHueColor(indexPrimary);
      color2 = getAvgHueColor(indexSecondary);
      this.color = color1;
      this.color2 = color2;
      this._loaded = true;
      if (typeof this.opts.ready === 'function') {
        return this.opts.ready.call(this);
      }
    };

    ImageEyeDropper.prototype.getSwatches = function(type, opts) {
      var angle, colors, h, normalizeAngle;
      if (opts == null) {
        opts = {};
      }
      if (!this.isReady()) {
        return false;
      }
      angle = (opts.angle || 30) / 360;
      normalizeAngle = function(a) {
        a = a - parseInt(a);
        if (a < 0) {
          a = 1 + a;
        }
        if (a > 1) {
          a = 1 - a;
        }
        return a;
      };
      colors = [this.color2.toHex()];
      h = this.color.toArray()[0];
      if (type === 'analogous') {
        colors.push(this.color.toHex());
        colors.push(this.color.h(normalizeAngle(h - angle)).toHex());
        colors.push(this.color.h(normalizeAngle(h + angle)).toHex());
      } else if (type === 'split-complementary') {
        colors.push(this.color.toHex());
        colors.push(this.color.h(normalizeAngle(h + 0.5 - angle / 2)).toHex());
        colors.push(this.color.h(normalizeAngle(h + 0.5 + angle / 2)).toHex());
      } else if (type === 'tetradic') {
        angle = (opts.angle || 60) / 360;
        colors.push(this.color.toHex());
        colors.push(this.color.h(h + angle).toHex());
        colors.push(this.color.h(normalizeAngle(h + 0.5)).toHex());
        colors.push(this.color.h(normalizeAngle(h + 0.5 + angle)).toHex());
      }
      this.color.h(h);
      return colors;
    };

    ImageEyeDropper.prototype.colorFromPoint = function(point) {
      var i, pixelIndex;
      i = pixelIndex = (point.y * this.width + point.x) * 4;
      return this.hex = '#' + normalizeRgba(this.rgb = [this.data[i], this.data[i + 1], this.data[i + 2]]).toHex();
    };

    ImageEyeDropper.prototype.imgClick = function(e) {
      return this.trigger('click', this.hex, this.rgb);
    };

    ImageEyeDropper.prototype.imgMousemove = function(e) {
      return this.trigger('mousemove', this.colorFromPoint(this.cursor = this._getCursor(e)), this.rgb);
    };

    ImageEyeDropper.prototype._getCursor = function(e) {
      return {
        x: e.offsetX,
        y: e.offsetY
      };
    };

    ImageEyeDropper.prototype.trigger = function(type) {
      var args, fns, func, _i, _len, _results;
      fns = this.fnStack[type];
      args = Array.prototype.slice.call(arguments, 1);
      if (fns != null) {
        _results = [];
        for (_i = 0, _len = fns.length; _i < _len; _i++) {
          func = fns[_i];
          _results.push(func.apply(this, args));
        }
        return _results;
      }
    };

    ImageEyeDropper.prototype.on = function(type, fn) {
      var _ref;
      return (this.fnStack[type] = (_ref = this.fnStack[type]) != null ? _ref : []).push(fn);
    };

    ImageEyeDropper.prototype.off = function(type, fn) {
      var fns, func, i, _i, _len, _results;
      fns = this.fnStack[type];
      if (typeof fn === "function" ? fn() : void 0) {
        _results = [];
        for (i = _i = 0, _len = fns.length; _i < _len; i = ++_i) {
          func = fns[i];
          _results.push(func === fn ? fns.splice(i, 1) : void 0);
        }
        return _results;
      } else {
        return delete this.fnStack[type];
      }
    };

    return ImageEyeDropper;

  })();

  normalizeRgba = function(rgb) {
    if (arguments.length > 1) {
      rgb = [arguments[0], arguments[1], arguments[2]];
    }
    return color.rgba({
      r: rgb[0] / 255,
      g: rgb[1] / 255,
      b: rgb[2] / 255
    });
  };

  window.ImageEyeDropper = ImageEyeDropper;

}).call(this);
