// Generated by CoffeeScript 1.3.3
(function() {
  var ImageEyeDropper, normalizeRgba;

  ImageEyeDropper = (function() {

    function ImageEyeDropper(img, opts) {
      if (opts == null) {
        opts = {};
      }
      this.fnStack = {};
      this.opts = opts;
      this.load(img);
    }

    ImageEyeDropper.prototype.load = function(img) {
      var imgObj,
        _this = this;
      if (typeof img === 'string') {
        if ((imgObj = document.getElementById(img)) && imgObj.tagName === 'IMG') {
          img = imgObj;
        }
      }
      this._loaded = false;
      return (this.img = img).addEventListener('load', function() {
        return _this._imageLoaded();
      });
    };

    ImageEyeDropper.prototype.isReady = function() {
      return this._loaded;
    };

    ImageEyeDropper.prototype._imageLoaded = function() {
      var canvas, ctx, h, rgbaData, w,
        _this = this;
      this.canvas = document.createElement('canvas');
      this.canvas.width = this.width = w = this.img.width;
      this.canvas.height = this.height = h = this.img.height;
      this.ctx = this.canvas.getContext('2d');
      this.ctx.drawImage(this.img, 0, 0, w, h);
      this.data = this.ctx.getImageData(0, 0, w, h).data;
      canvas = document.createElement('canvas');
      canvas.width = w = 64;
      canvas.height = h = 64 * this.height / this.width;
      ctx = canvas.getContext('2d');
      ctx.drawImage(this.img, 0, 0, w, h);
      rgbaData = ctx.getImageData(0, 0, w, h).data;
      this.analyzeData(rgbaData, w * h);
      if (this.opts.disableMouse !== true) {
        this.img.addEventListener('click', function(e) {
          return _this.imgClick(e);
        });
        return this.img.addEventListener('mousemove', function(e) {
          return _this.imgMousemove(e);
        });
      }
    };

    ImageEyeDropper.prototype.analyzeData = function(d, len) {
      var buckets, color1, getAvgColor, getAvgHueColor, hsvData, i, indexPrimary1, lengths, popMax, pushHsv, sat, val, _b, _i,
        _this = this;
      hsvData = [];
      buckets = [];
      _b = 24;
      sat = 0;
      val = 0;
      pushHsv = function(i) {
        var hex, hsva, hue, p, _ref, _ref1;
        i = i * 4;
        hex = normalizeRgba(d[i], d[i + 1], d[i + 2]).toHex();
        hsva = color.hsva(hex).toArray();
        hue = hsva[0] * 100;
        p = parseInt(hue % _b, 10);
        sat += hsva[1];
        val += hsva[2];
        if (typeof buckets[p] === 'undefined') {
          buckets[p] = [];
        }
        if ((0.92 > (_ref = hsva[1]) && _ref > 0.08) && (0.92 > (_ref1 = hsva[2]) && _ref1 > 0.08)) {
          buckets[p].push(hsva);
        }
        return hsvData.push(hsva);
      };
      for (i = _i = 0; 0 <= len ? _i <= len : _i >= len; i = 0 <= len ? ++_i : --_i) {
        pushHsv(i);
      }
      this.avgSat = sat / len;
      this.avgVal = val / len;
      lengths = buckets.map(function(b) {
        if (b) {
          return b.length;
        } else {
          return 0;
        }
      });
      popMax = function() {
        var index, max;
        max = Math.max.apply(null, lengths);
        index = lengths.indexOf(max);
        lengths[index] = 0;
        return index;
      };
      indexPrimary1 = popMax();
      getAvgColor = function(s, c) {
        s.h += c[0];
        s.s += c[1];
        return s.v += c[2];
      };
      getAvgHueColor = function(index) {
        var hsva, l, s, _j, _len, _ref;
        l = buckets[index].length;
        s = {
          h: 0,
          s: 0,
          v: 0
        };
        _ref = buckets[index];
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          hsva = _ref[_j];
          getAvgColor(s, hsva);
        }
        return color.hsva({
          h: s.h / l,
          s: s.s / l,
          v: s.v / l
        });
      };
      color1 = getAvgHueColor(indexPrimary1);
      this.color = color1;
      this._loaded = true;
      if (typeof this.opts.ready === 'function') {
        return this.opts.ready.call(this);
      }
    };

    ImageEyeDropper.prototype.getSwatches = function(type, opts) {
      var a1, a2, a3, a4, angle, h, normalizeAngle;
      if (opts == null) {
        opts = {};
      }
      if (!this.isReady()) {
        return false;
      }
      angle = (opts.angle || 30) / 360;
      normalizeAngle = function(a) {
        a = a - parseInt(a);
        if (a < 0) {
          a = 1 + a;
        }
        if (a > 1) {
          a = 1 - a;
        }
        return a;
      };
      h = this.color.toArray()[0];
      if (type === 'analogous') {
        a1 = this.color.toHex();
        a2 = this.color.h(normalizeAngle(h - angle)).toHex();
        a3 = this.color.h(normalizeAngle(h + angle)).toHex();
        this.color.h(h);
        return [a1, a2, a3];
      } else if (type === 'split-complementary') {
        a1 = this.color.toHex();
        a2 = this.color.h(normalizeAngle(h + 0.5 - angle / 2)).toHex();
        a3 = this.color.h(normalizeAngle(h + 0.5 + angle / 2)).toHex();
        this.color.h(h);
        return [a1, a2, a3];
      } else if (type === 'tetradic') {
        angle = (opts.angle || 60) / 360;
        a1 = this.color.toHex();
        a2 = this.color.h(h + angle).toHex();
        a3 = this.color.h(normalizeAngle(h + 0.5)).toHex();
        a4 = this.color.h(normalizeAngle(h + 0.5 + angle)).toHex();
        this.color.h(h);
        return [a1, a2, a3, a4];
      }
    };

    ImageEyeDropper.prototype.colorFromPoint = function(point) {
      var i, pixelIndex;
      i = pixelIndex = (point.y * this.width + point.x) * 4;
      return this.hex = '#' + normalizeRgba(this.rgb = [this.data[i], this.data[i + 1], this.data[i + 2]]).toHex();
    };

    ImageEyeDropper.prototype.imgClick = function(e) {
      return this.trigger('click', this.hex, this.rgb);
    };

    ImageEyeDropper.prototype.imgMousemove = function(e) {
      return this.trigger('mousemove', this.colorFromPoint(this.cursor = this._getCursor(e)), this.rgb);
    };

    ImageEyeDropper.prototype._getCursor = function(e) {
      var _ref;
      if ((_ref = this._offset) == null) {
        this._offset = this._getOffset();
      }
      return {
        x: e.clientX - this._offset.x,
        y: e.clientY - this._offset.y
      };
    };

    ImageEyeDropper.prototype._getOffset = function() {
      var obj, x, y;
      x = y = 0;
      obj = this.img;
      while (obj.offsetParent) {
        x += obj.offsetLeft;
        y += obj.offsetTop;
        obj = obj.offsetParent;
      }
      return this._offset = {
        x: x,
        y: y
      };
    };

    ImageEyeDropper.prototype.trigger = function(type) {
      var args, fns, func, _i, _len, _results;
      fns = this.fnStack[type];
      args = Array.prototype.slice.call(arguments, 1);
      if (fns != null) {
        _results = [];
        for (_i = 0, _len = fns.length; _i < _len; _i++) {
          func = fns[_i];
          _results.push(func.apply(this, args));
        }
        return _results;
      }
    };

    ImageEyeDropper.prototype.on = function(type, fn) {
      var _ref;
      return (this.fnStack[type] = (_ref = this.fnStack[type]) != null ? _ref : []).push(fn);
    };

    ImageEyeDropper.prototype.off = function(type, fn) {
      var fns, func, i, _i, _len, _results;
      fns = this.fnStack[type];
      if (typeof fn === "function" ? fn() : void 0) {
        _results = [];
        for (i = _i = 0, _len = fns.length; _i < _len; i = ++_i) {
          func = fns[i];
          _results.push(func === fn ? fns.splice(i, 1) : void 0);
        }
        return _results;
      } else {
        return delete this.fnStack[type];
      }
    };

    return ImageEyeDropper;

  })();

  normalizeRgba = function(rgb) {
    if (arguments.length > 1) {
      rgb = [arguments[0], arguments[1], arguments[2]];
    }
    return color.rgba({
      r: rgb[0] / 255,
      g: rgb[1] / 255,
      b: rgb[2] / 255
    });
  };

  window.ImageEyeDropper = ImageEyeDropper;

}).call(this);
